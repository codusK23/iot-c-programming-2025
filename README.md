# iot-c-programming-2025
IoT 개발자 심화 프로그래밍 언어(C/C++) 리포지토리

## 1일차
- 프로그래밍 언어 종류
    - 저급언어: 컴퓨터가 직접 이해하고 실행하는 언어. ex) 기계어, 어셈블리어
    - 고급언어: 사용자가 이해하기 쉽게 만들어진 언어. ex) C/C++, Python, JAVA
    - 절차지향 언어 : 함수 중요
    - 객체지향 언어 : 클래스 중요

- Visual Studio c언어 파일 만들기: 소스파일 -> 추가 -> 새파일 -> 파일명 설정

- c언어 기본셋팅
    ```c
    #include <stdio.h>

    int main() 
    {
        return 0;
    }
    ```
    - #include <stdio.h> : stdio.h라는 헤더파일(.h)을 포함하라는 의미.
    - 메인 함수는 운영체제가 호출함
    - void main() : 반환 값 X
    - int main(void) : 입력 값 X

- bit, byte, nybble, 진수, 보수
    - bit : 0 또는 1인 값
    - byte : 8bit
    - nybble : 4bit
    - 진수: 숫자를 표현하는 방식,
        - 2진수: 0 또는 1
        - 10진수 : 0 ~ 9, %d
        - 8진수 : 0 ~ 7, %o 
        - 16진수 : 0 ~ 9, A(10) ~ F(15), %x
    - 뺄셈 연산, 보수 사용
        - 1의 보수: 0은 1, 1은 0으로 비트 반전
        - 2의 보수: 1의 보수 결과에 1을 더함.

- 자료형
    - int : 정수형(%d)
    - float : 실수형(%f)
    - double : 실수형(%lf)
    - char : 문자형(%c) | 문자열(%s), 문자는 출력함수 printf()에서 따옴표(''), 문자열은 쌍따옴표 ("")

- ROM과 RAM
    - ROM : 읽기 전용 메모리(데이터 수정 불가능), 비휘발성 메모리로 전원이 꺼져도 저장된 데이터는 사라지지 않음. 느림
    - RAM : 읽기/쓰기 메모리(데이터 수정 가능), 휘발성 메모리로 전원이 꺼지면 저장된 모든 데이터가 사라짐. 빠름, 변수는 RAM에 저장.

- 변수
    - 값을 저장하는 메모리 공간, 값 수정가능
    - 변수 선언 및 초기화: 자료형 변수이름(lvalue) = 값(rvalue, literal);
    - 전역변수 : 프로그램 전체에서 접근가능
    - 지역변수 : 특정함수 내에서만 사용가능
    - signed : 부호 있는 값, 양수와 음수 모두 저장 : -128 ~ 127
    - unsigned : 부호 없는 값, 양수만 저장 : 0 ~ 255
    - signed, unsigned : int, char, short, long 등의 정수형 자료형에 적용.

- 상수
    - 변하지 않는 고정된 값
    - #define, const 키워드 사용 : const 자료형 변수이름 = 값;

- 배열
    - 같은 데이터 타입을 가지는 연속된 메모리 공간
    - 배열은 배열의 시작주소를 나타냄 -> 주소연산자 필요X (변수는 주소연산자 사용)
    - 맨 마지막 배열에는 배열의 끝을 의미하는 **null**이 입력됨

- printf(); : 출력함수
- scanf() : 입력함수
    - 열의 크기를 자동적으로 알지 못하기 때문에 **sizeof()** 함수 사용


## 2일차
- 연산자 종류
    - 산술연산자 : +, -, *, /, %
    - 비교연산자 : ==, !=, <, >, <=, >=
    - 논리연산자 : &&, ||, !
    - 비트연산자 : &, |, ^, ~, <<, >>
    - 대입연산자 : =, +=, -=, *=, /=, %=
    - 증감연산자 : ++, --
    - 삼항연산자 : (조건 ? 참 : 거짓)
    - 연산자 우선순위 : 산술 -> 비교 -> 비트 -> 논리 -> 대입

- 선택 제어문
    - if, if-else, if-else if-else : if(조건식) {...}
    - switch-case : switch(변수){case 값1:... case 값2:... default:...}
        - break 없으면 끝까지 실행, break있으면 switch문 종료

- 반복 제어문
    - for (초기값; 조건식; 증감식;){...}
    - while (조건식) {...} : break(반복문 종료), continue(다음 반복 진행)

- 사용자 정의 함수
    - 입력과 출력이 없는 함수: 함수 안에서 결과를 나타냄.
        - void 함수이름(){...}
    - 입력만 있는 함수: 실인수를 입력받음.
        - void 함수이름(자료형 매개변수1, ...){...}
    - 입력과 출력이 있는 함수: 실인수를 입력받고, return으로 값을 반환함.
        - 자료형 함수이름(자료형 매개변수1, ...){... return 리턴 값}
        - 계산기 만들기 실습 파일[C](./day02/func4.c)


## 3일차
- 배열
    - 선언 및 초기화 방법: 자료형 배열이름[배열크기] = {...} (배열크기 생략가능)
    - 장점: 순회, 탐색 좋음, 단점: 수정이 어려움 -> 인덱스 사용(값에 접근하기)
    - 문자형 배열의 경우 문자형 배열의 끝을 알리는 null이 저장될 수 있게 (입력할 값 갯수 + 1)을 배열 크기로 지정

- 포인터
    - 메모리 주소를 저장할 수 있는 공간
    - 선언 방법: 자료형* 포인터변수이름; 
        - (이 때 *는 포인터 변수임을 뜻하는 표시일 뿐 아무 의미 없음.)
    - int* p 일 경우
        - 포인터 변수에 저장된 값을 확인하고 싶을 때: p
        - 포인터 변수가 가리키는 곳의 값을 확인할 때: *p (이 때 *는 간접참조연산자)
    - 포인터를 이용한 swap함수 생성 [C](./day03/pointer4.c)
    - 포인터 배열: 인덱스[] 표현 -> *(포인터변수 + 인덱스)
        - [C](./day03/pointer5.c)
        - [C](./day03/pointer6.c)
    - 포인터 상수: const
        - **const** int* 포인터변수 = &변수 : 데이터 상수, 포인터 변수를 통한 데이터의 값 변경을 불허함
        - int* **const** 포인터변수 = &변수 : 포인터 상수, 포인터 변수가 가리키는 주소의 값 변경을 불허함

- 문자 전용 함수
    - 문자 하나를 입력받고 출력하기에 번거로움: getchar, putchar 사용
    - getchar() : 한 문자를 읽어오는 함수 (입력) [C](./day04/char4.c)
    - putchar() : 한 문자를 출력하는 함수 (출력)
        - 줄바꿈이 안 되는 단점이 있음 따로 putchar('\n') 추가


## 4일차
- 주소
    - 데이터영역 주소
        - 힙 : 사용자에게 할당된 메모리 영역
        - stack : 지역변수, 매개변수
        - data: 전역변수 , static
        - rod: 문자열 상수, 리터럴
    - 코드영역 주소
        - 함수, 제어문

- 문자열 전용 함수
    - gets, fgets : 문자열 입력 함수
    - puts, fputs : 문자열 출력 함수
    - strcpy, strncpy : 문자열 복사 함수
    - strcmp, strncmp : 문자열 비교 함수
    - strcat, strncat : 문자열 연결 함수
    - strlen : 문자열 길이 계산함수

- 변수
    - 전역변수: 프로그램 전체
    - 지역변수: 블록안에서만 사용(매개변수, 자동변수)
    - 정적변수: 전역+ 지역


## 5일차
- 포인터 배열 : 포인터를 저장하고 있는 배열 ex) int* arr[5]; -> 포인터 5개 저장하는 배열

- 배열 포인터 : 배열의 시작 주소를 저장하는 포인터 ex) int (*arr)[5]; -> 원소가 5개인 배열의 포인터

- 함수 포인터 : 반환 자료형 (*포인터 이름)(매개변수 타입); ex) int (*func)(int, int);
    - [C](./day05/voidpointer.c)

- malloc - free : 메모리 동적 할당 및 해제, 힙영역에 입력크기만큼 메모리 공간을 할당받고 시작 주소 리턴.
    - 정수 배열 동적 할당 : int* arr = (int*)malloc(sizeof(int) * n)
    - 문자열 동적 할당 : char* str = (char*)malloc(strlen(input) + 1)

- 구조체 : 사용자 정의 자료형, 기존 자료형을 묶어서 만든 복합 자료형(타입)
    - 선언
        ```c
        struct Human			
        {
            char name[100];	
            int age;
        };
        ```
    - 사용 : (.)멤버 접근 연산자
        ```c
        struct Human h;		
        h.age = 30;		
        ```
    - typedef : 별칭 설정
    - 구조체 포인터
        - . : 구조체 변수를 통해서 멤버에 접근하는 방법
        - -> : 구조체 포인터를 통해서 멤버에 접근하는 방법
    - 참고 : [C](./day05/struct5.c)


## 6일차
- c++ Hello World 출력
    ```c++
    #include <iostream>

    int main(){

        std::cout << "Hello World!" << std::endl;

        return 0;
    }
    ```
    - cout : 출력을 담당하는 객체. 연산자 << 사용
    - std : using namespace std; 로 생략가능.(권장X, 충돌 가능성 있음)
    - endl : 개행(\n) 및 출력 버퍼 비움

- cin : 입력을 담당하는 객체. 연산자 >> 사용

- namespace : 동일한 이름을 가진 것들의 충돌을 방지하는 기능

- 함수의 다형성
    - 함수 오버로딩 (함수의 다중정의) : 이름은 같지만 매개변수의 타입이나 갯수가 다를 경우 다른 함수.
        - 디폴트 매개변수 : 입력이 없을 시 적용. 함수 원형에만 작성. 여러개 적용시 맨 오른쪽부터 작성. 함수오버로딩 중 디폴트 매개변수와 입력이 없는 순수한 함수 정의가 있을 때 입력없는 함수 호출 시 함수가 겹치는 문제 발생
    - 함수 오버라이딩 (함수의 재정의) -> 상속

- new - delete : c++ 메모리 동적 할당 및 해제, c언어에서의 malloc - free
    - 생성자 : 객체를 생성하고, 초기화 시키는 기능을 가지는 특별한 메서드.
    - new : 힙 메모리에 공간 할당. 생성자 호출, 초기화 가능
    - delete : 할당된 메모리 해제. 배열에서는 delete[] 사용

- 참조자 : Reference : 별칭. 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름
    - & : 레퍼런스 선언 할 때 사용
    - 상수 레퍼런스 : 임시객체는 참조할 수 없지만 const 사용하여 참조 시 리터럴도 참조 가능. 임시 객체를 저장할 수 있는 공간 생성
        - 함수의 출력이 레퍼런스인 경우 : 참조 사용유무 상관X


## 7일차
- 클래스
    - 접근제어 지시자
        - private : 클래스 내부에서만 접근 가능. 외부 접근 허용X
        - public : 어디에서든지 접근 가능.
        - protected : 클래스 내부 및 자식클래스만 접근 허용(상속)
    - 구성요소
        - 멤버 변수(속성. private영역)
        - 멤버 함수(메서드: 기능. public 영역)
        - 생성자, 소멸자
    - 클래스 실습
        - getData(), setData() : [C++](./day07/MyClass_1.cpp)
        - 생성자 생성 : [C++](./day07/MyClass_2.cpp)
        - 생성자 내 동적 메모리 할당 및 해제(소멸자) : [C++](./day07/MyClass_3.cpp)
        - 클래스 밖에서 멤버함수 구현 : [C++](./day07/MyClass_4.cpp)
        - 콜론 초기화 : 생성자 헤드 부분에 콜론(:)을 사용하여 초기화 진행, 생성자 실행 전에 초기화가 진행되어야 할 때 주로 사용
            - 상수 초기화
            - 레퍼런스 초기화
            - 객체를 생성자로 가지는 경우
            - [C++](./day07/init4.cpp)
        - 임시 객체 생성 : 클래스 객체이름 = 생성자(); [C++](./day07/init3.cpp)

- 문자열 처리하기 : [C++](./day07/문자열처리하기.cpp)


## 8일차
- 복사 생성자 : 기존의 객체를 사용하여 새로운 객체를 생성할 때 호출. 클래스 이름 옆 &(참조) 연산자 사용. 디폴트제공됨
    - [C++](./day08/operator.cpp)
    - 얕은 복사 : obj1 = obj2
    - 깊은 복사 : 메모리 동적 할당

- 변환 생성자 : 명시적인 타입 변환 없이 타입이 다른 객체를 생성 가능.

- 이동 생성자 : 기존 객체값을 새로운 객체로 이동할 때 사용(복사와 다름). &&(rvalue reference) 연산자 사용
    - noexcept : 데이터가 이동하는 도중 발생하는 문제를 방지하기 위해 예외가 발생하지 않는 함수라는 의미

- static : 클래스 멤버, 객체별로 생성되는 것이 아닌 기존에 만들어진 멤버 함수를 공유함. ->  각 객체가 아닌 클래스 자체에 속하기 때문
    - static 멤버 변수 초기화는 클래스 외부에서 이루어져야 함.
    - static 멤버 함수 : static 멤버 변수에만 접근 가능. 일반 멤버 접근 허용 X
    - [C++](./day08/static3.cpp)


- this -> : 자기자신의미 (**수정**)

- 은행뱅킹 시스템 실습 : [C++](./Banking/BankingSystemver02.cpp)


## 9일차
- operator
    - 연산자 오버로딩
        - 초기값을 가지는 객체 생성
        - 객체를 복사해서 새로운 객체 생성 obj2(obj) / obj2 = obj
        - 객체 연산결과로 새로운 객체 생성

    - 전역함수 오버로딩
        - inline : public
        - friend : private, protected
- 템플릿


## 10일차
- 상속
    - private, public, protected
    - is a(관계), has a(소유) 관계 성립되어야 함.
    - 부모클래스 : 기초클래스, 슈퍼클래스, 베이스클래스
    - 자식클래스 : 파생클래스, 서브클래스, 드라이버드클래스
    - 상속 방법
        - class 자식클래스 : public 부모클래스 {};
        - 상속받은 멤버들은 상속한 부모클래스의 생성자에서 초기화를 해야함 (콜론 초기화 사용)
    - 생성자 호출과 생성자 실행은 다름

- 객체 포인터
    - 객체 동적 메모리 할당 및 해제
        - 할당 : AClass* ptr = new AClass{};
        - 해제 : delete ptr;
    - 오버라이딩: 자식클래스에서 부모 클래스 멤버 함수를 재정의
    - upcasting : 부모 타입의 포인터로 자식 타입의 객체를 가리킨다. -> 자식타입의 객체 부모타입으로 업캐스팅.
    - downcasting : 자식 타입의 포인터로 부모 객체를 가리킬 수 없다.

- virtual
    - virtual function : 
    - virtual class :


## 11일차
- casting
    - static_cast
    - dynamic_cast
    - const_cast

- 스마트 포인터
    - unique
    - shared
    - weak

- STL(Standard Template Library)
    - container : 객체를 저장하고 관리하는 자료구조
        - 시퀀스 컨테이너 : 선형적으로 데이터 저장(순서)
        - 연관 컨테이너 : 일정한 규칙으로 저장
        - 컨테이너 어댑터 : 변형

## 12일차
- 비쥬얼 스튜디오 데이터베이스 연결 방법
    - mysql c++ 커넥션 설치
    - mysql workbench : mysql connection established 오류 발생
        - 포트 잠김으로 인한 문제
        - NAT 서비스가 해당 포트를 다른 프로세스와 잘못 매핑하거나, 패킷을 잘못 처리할 경우 등의 문제
            - nat 서비스 종료 후 재실행
            - cmd 관리자 모드 실행
                - new stop winnat
                - new start winnat

- miniproject
    - 계획 수립, 역할 지정
